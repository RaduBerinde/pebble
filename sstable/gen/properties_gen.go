// Copyright 2018 The LevelDB-Go and Pebble Authors. All rights reserved. Use
// of this source code is governed by a BSD-style license that can be found in
// the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"os"
	"reflect"

	"github.com/cockroachdb/pebble/sstable"
)

type fieldInfo struct {
	tag    string
	name   string
	offset uintptr
	typ    reflect.Kind
}

func getFieldInfo(t reflect.Type) []fieldInfo {
	var res []fieldInfo
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		if f.Type.Kind() == reflect.Struct {
			if tag := f.Tag.Get("prop"); i == 0 && tag == "pebble.embbeded_common_properties" {
				// CommonProperties struct embedded in Properties. Note that since
				// CommonProperties is placed at the top of properties we can use
				// the offsets of the fields within CommonProperties to determine
				// the offsets of those fields within Properties.
				res = append(res, getFieldInfo(f.Type)...)
				continue
			}
			panic("pebble: unknown struct type in Properties")
		}
		if tag := f.Tag.Get("prop"); tag != "" {
			res = append(res, fieldInfo{
				tag:    tag,
				name:   f.Name,
				offset: f.Offset,
				typ:    f.Type.Kind(),
			})
		}
	}
	return res
}

var buf bytes.Buffer

func out(format string, args ...interface{}) {
	fmt.Fprintf(&buf, format+"\n", args...)
}

func genLoadField(fields []fieldInfo) {
	out(`
// loadField loads the value of the field with the given tag and updates the
// loaded fields map.
//
// If the tag does not correspond to a field, returns false.
func (p *Properties) loadField(tag string, value []byte, loaded map[uintptr]struct{}) bool {
	switch tag {`)
	for _, f := range fields {
		out(`	case %q:`, f.tag)
		switch f.typ {
		case reflect.Bool:
			out(`	  p.%s = bytes.Equal(value, propBoolTrue)`, f.name)

		case reflect.Uint32:
			out(`	  p.%s = binary.LittleEndian.Uint32(value)`, f.name)

		case reflect.Uint64:
			if f.tag == sstable.PropGlobalSeqnumName {
				out(`	  p.%s = binary.LittleEndian.Uint64(value)`, f.name)
			} else {
				out(`	  p.%s, _ = binary.Uvarint(value)`, f.name)
			}
		case reflect.String:
			out(`	  p.%s = intern.Bytes(value)`, f.name)

		default:
			panic("not reached")
		}
		out(`		loaded[%d] = struct{}{}`, f.offset)
		out(``)
	}
	out(`	default:`)
	out(`		return false`)
	out(`	}`)
	out(``)
	out(`	return true`)
	out(`}`)
}

func genPropOffsetTagMap(fields []fieldInfo) {
	out(``)
	out(`// propOffsetTagMap maps offset inside struct to tag.`)
	out(`var propOffsetTagMap = map[uintptr]string{`)
	for _, f := range fields {
		var space string
		for i := len(fmt.Sprintf("%d", f.offset)); i < 3; i++ {
			space += " "
		}
		out(`	%d: %s%q,`, f.offset, space, f.tag)
	}
	out(`}`)
}

func main() {
	fields := getFieldInfo(reflect.TypeOf(sstable.Properties{}))

	out(`// Autogenerated - DO NOT EDIT`)
	out(``)
	out(`package sstable`)
	out(``)
	out(`import (`)
	out(`	"bytes"`)
	out(`	"encoding/binary"`)
	out(``)
	out(`	"github.com/cockroachdb/pebble/internal/intern"`)
	out(`)`)

	genLoadField(fields)
	genPropOffsetTagMap(fields)

	if err := os.WriteFile("properties_load.go", buf.Bytes(), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "error writing file: %s", err)
		os.Exit(1)
	}
}
